% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_lineseg_grid.R
\name{plot_lineseg_grid}
\alias{plot_lineseg_grid}
\title{Plot comparison of two items with respec to the grid search}
\usage{
plot_lineseg_grid(
  Lambda,
  Linedf,
  item_pair = c(1, 2),
  triangle = "right",
  annotations = FALSE,
  leg.pos = "none"
)
}
\arguments{
\item{Lambda}{Data frame containing weight vectors and labels for weighted rank aggregations.
Must include column names lambda1/2 for right triangle representation or
equilambda1/2 for equilateral triangle representation.}

\item{Linedf}{A data frame containing information of line segments, computed from
\code{\link[=rank_decomposition_exact]{rank_decomposition_exact()}}.}

\item{item_pair}{A pair of indices using c(A,B) notation}

\item{triangle}{Specify whether the right triangle representation ("right") or the
equilateral triangle representation ("equilateral"). Note that the equilateral triangle
representation is recommended as it is unbiased, and the right triangle representation is
biased.}

\item{annotations}{Boolean for whether to include annotations in the graph}

\item{leg.pos}{Input for ggplot legend positioning, e.g. 'bottom', 'right', or c(0.8,0.8)}
}
\value{
A ggplot structure which can be plotted directly.
}
\description{
Input a pair of indices as a list, e.g., c(1,2).
The line segment separating this adjacent transposition will be plotted.
The data from the grid search will be colored to compare whether the two agree.
}
\examples{
Lambda <- weight_set(0.01)
rankdf <- data.frame('rank1'=c(1,2,3,4,5), 
           'rank2'=c(2,3,1,5,4), 'rank3'=c(3,1,5,4,2))
Lambda <- rank_aggregation_grid(Lambda,rankdf)
plot_aggregation_grid(Lambda)
outlist <- rank_decomposition_exact(metrics,Lambda)
Linedf <- outlist[[1]]
g <- plot_lineseg_grid(Lambda,Linedf,item_pair=c(1,2))
g
plot_lineseg_grid(Lambda,Linedf,item_pair=c(1,3),annotations=TRUE)
g <- plot_aggregation_grid(Lambda,plotly_text = TRUE)
plotly::ggplotly(g, tooltip='text')
}
