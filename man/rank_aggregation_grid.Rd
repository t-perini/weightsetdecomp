% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rank_aggregation_grid.R
\name{rank_aggregation_grid}
\alias{rank_aggregation_grid}
\title{Weighted rank aggregation via uniform grid search over weight set}
\usage{
rank_aggregation_grid(
  num_metrics = 3,
  Lambda,
  metrics,
  ties = FALSE,
  show_bar = FALSE
)
}
\arguments{
\item{num_metrics}{The dimension of the problem indicating total number of metrics to be aggregated
(3, 4, or 5)}

\item{Lambda}{Data frame containing weight vectors with column names lambda1, lambda2, lambda3}

\item{metrics}{Data frame for 3 metrics, one metric per column, one row per item, smaller values are better}

\item{ties}{Boolean for whether to allow for ties (TRUE) or not (FALSE)}

\item{show_bar}{Boolean for a progress bar printed in console}
}
\value{
An extended data frame with new columns Label and ItemLabel.
Rank.Label is a string (factor, separated by periods) that lists the ranked position per item in
the order of items. This is the precise description of the aggregated rank, but not very interpretable.
Item.Label gives the order of items ranked from best-to-last. This is easier to interpret than Rank.Label.
}
\description{
For every weight vector (row) of data frame, compute the weighted rank aggregation and generate
a string label. The strings are concatenations of the elements in order from best to worst,
separated by periods. Note that grid search is not guaranteed to capture every possible weighted
rank aggregation; the density of the mesh grid determines the number of indifference regions
discovered. Smaller step size of the grid leads to capturing more indifference regions at
the cost of additional computations.
}
\examples{
Lambda <- weight_set()
metrics <- data.frame('cost'=c(10,20,30,40), 'time'=c(5.9, 3.3, 2.5, 4.1), 'risk'=c(1,4,3,2))
Lambda <- rank_aggregation_grid(3,Lambda,metrics)
Lambda <- rank_aggregation_grid(Lambda = Lambda, metrics = metrics)
}
